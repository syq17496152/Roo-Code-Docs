---
title: MCP 与 API
sidebar_label: MCP 与 API
---

# MCP 与 REST APIs：根本区别

将 REST API 与模型上下文协议 (MCP) 进行比较是一个类别错误。它们在不同的抽象层上运行，并在 AI 系统中服务于根本不同的目的。

// ... existing code ...

## 架构差异

| 特性 | MCP | REST API |
|---------|-----|-----------|
| 状态管理 | **有状态** - 在交互间保持上下文 | **无状态** - 每个请求都是独立的 |
| 连接类型 | 持久、双向连接 | 单向请求/响应 |
| 通信风格 | 基于 JSON-RPC 的持续会话 | 基于 HTTP 的独立请求 |
| 上下文处理 | 协议内在包含上下文 | 必须手动管理上下文 |
| 工具发现 | 运行时发现可用工具 | 设计时集成需要预先了解 |
| 集成方式 | 运行时集成动态能力 | 设计时集成需要代码更改 |

// ... existing code ...

## 不同层级，不同目的

REST API 和 MCP 在技术栈中服务于不同的层级：

1. **REST**：低级 Web 通信模式，暴露资源上的操作
2. **MCP**：高级 AI 协议，协调工具使用并维护上下文

MCP 通常在内部使用 REST API，但对 AI 隐藏它们。将 MCP 视为中间件，它将离散的 Web 服务转化为 AI 可以在其中操作的统一环境。

// ... existing code ...

## 动态工具发现

MCP 使 AI 能够在运行时发现和使用工具：

```json
// AI 发现可用工具
{
  "tools": [
    {
      "name": "readFile",
      "description": "从文件中读取内容",
      "parameters": {
        "path": { "type": "字符串", "description": "文件路径" }
      }
    },
    {
      "name": "createTicket",
      "description": "在问题跟踪器中创建工单",
      "parameters": {
        "title": { "type": "字符串" },
        "description": { "type": "字符串" }
      }
    }
  ]
}
```

这种 "即插即用" 的功能允许添加新工具而无需重新部署或修改 AI 本身。

// ... existing code ...

## 为什么 Roo Code 使用 MCP

Roo Code 利用 MCP 提供：

1. **可扩展性**：添加无限的自定义工具而无需等待官方集成
2. **上下文感知**：工具可以访问对话历史和项目上下文
3. **简化集成**：一个标准协议而不是众多 API 模式
4. **运行时灵活性**：即时发现和使用新功能

MCP 在 Roo Code 和外部服务之间创建了一个通用连接器，而 REST API 通常在幕后为这些服务提供支持。

// ... existing code ...

## 结论：互补而非竞争的技术

MCP 并不取代 REST API - 它是在其基础上构建的。REST 擅长提供离散服务，而 MCP 擅长为 AI 代理协调这些服务。

关键区别在于 MCP 是 AI 原生的：它将模型视为一等用户，提供 AI 代理在复杂环境中有效运行所需的上下文、有状态交互层。