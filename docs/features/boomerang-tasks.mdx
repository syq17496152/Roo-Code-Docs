---
sidebar_label: '回旋镖任务'
---

# 回旋镖任务：协调复杂工作流

回旋镖任务（也称为子任务或任务编排）允许您使用内置的 **`🪃 编排器` 模式（又名回旋镖模式）** 将复杂项目分解为更小、更易管理的部分。可以将其想象成将部分工作委托给专业助手。每个子任务在其自己的上下文中运行，通常使用针对特定任务（如 [`💻 代码`](/basic-usage/using-modes#code-mode-default)、[`🏗️ 架构师`](/basic-usage/using-modes#architect-mode) 或 [`🪲 调试`](/basic-usage/using-modes#debug-mode)）定制的不同 Roo Code 模式。编排器模式负责管理这一过程。

<div style={{ position: 'relative', paddingBottom: '56.25%', height: 0, overflow: 'hidden' }}>
  <iframe
    src="https://www.youtube.com/embed/RX862U09fnE"
    style={{
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
    }}
    frameBorder="0"
    allow="autoplay; encrypted-media"
    allowFullScreen
  ></iframe>
</div>

<br />

:::info 编排器模式是内置的
`🪃 编排器` 模式（以前通过自定义 "回旋镖模式" 实现）现在是一个内置模式，专门设计用于通过分解任务并将其委派给其他模式来编排工作流程。您不再需要为此功能创建自定义模式。

了解更多关于 [内置模式](/basic-usage/using-modes#built-in-modes) 的信息。
:::

---

## 为什么使用回旋镖任务？

-   **应对复杂性：** 将大型多步骤项目（例如，构建完整功能）分解为专注的子任务（例如，设计、实现、文档）。
-   **使用专业化模式：** 自动将子任务委派给最适合该特定工作的模式，利用其专业化能力以获得最佳结果。
-   **保持专注 & 高效率：** 每个子任务在独立的上下文中运行，拥有单独的对话历史记录。这防止了父（编排器）任务因详细执行步骤（如代码差异或文件分析结果）而变得混乱，使其能够专注于高层次的工作流程，并根据已完成子任务的简洁摘要有效地管理整个过程。
-   **简化工作流程：** 来自一个子任务的结果可以自动传递到下一个，创建流畅的流程（例如，架构决策输入编码任务）。

---

## 它是如何工作的

1.  当处于 [`🪃 编排器`](/basic-usage/using-modes#orchestrator-mode-aka-boomerang-mode) 模式（又名回旋镖模式）时，Roo 分析复杂任务并建议将其分解为子任务[^1]。

2.  父任务（在编排器模式中）暂停，新子任务在不同的专用模式[^2] 中开始。
3.  当子任务目标达成时，Roo 发出完成信号。
4.  父任务仅用子任务的摘要[^3] 恢复。父任务使用此摘要继续主工作流程。

---

## 关键注意事项

-   **需要批准：** 默认情况下，必须批准每个子任务的创建和完成。如果需要，可以通过 [自动批准操作](/features/auto-approving-actions#subtasks) 设置来自动化。
-   **上下文隔离与传递：** 每个子任务在其独立的对话历史记录中完全隔离运行。它不会自动继承父任务的上下文。必须显式传递信息：
    *   **向下：** 通过创建子任务时提供的初始指令。
    *   **向上：** 通过子任务完成时提供的最终摘要。请注意，只有这个摘会被返回给父任务。
-   **导航：** Roo 的界面帮助您查看任务层次结构（哪个任务是父任务，哪些是子任务）。通常可以在活动和暂停的任务之间导航。

回旋镖任务提供了一种强大的方式，在 Roo Code 内直接管理复杂的开发工作流程，通过专用模式实现最大效率。

:::tip 让任务保持专注
使用子任务（通过编排器模式委派）来保持清晰。如果请求显著转移焦点或需要不同专业知识（模式），请考虑创建子任务而不是使当前任务超载。
:::

---

## 常见问题解答

### 为什么编排器模式不能读取文件、写入文件、调用 MCP 或运行命令？

编排器模式有意限制以专注于高层工作流程管理。默认情况下赋予其读取文件的能力会导致上下文填充文件读取内容，阻碍其保持聚焦于编排的能力。设计理念是子任务应处理详细工作，并仅通过它们的完成摘要返回必要信息（通过它们的完成摘要）以便编排器有效委派进一步任务。

这种限制有助于防止 [上下文污染](/advanced-usage/context-poisoning)，即不相关或过多的信息污染模型的活跃上下文，导致性能下降和任务偏离。

### 我如何覆盖编排器模式的限制？

您可以按照 [配置优先级](/features/custom-modes#configuration-precedence) 系统通过 [自定义编排器模式](/features/custom-modes) 添加诸如文件读取之类的功能：

1. 打开命令面板并选择 **"编辑全局模式"**
2. 复制粘贴以下配置：

```json
{
  "customModes": [
    {
      "slug": "orchestrator",
      "name": "🪃 编排器",
      "roleDefinition": "你是 Roo，一位战略工作流程编排器，通过将任务委托给适当的专用模式来协调复杂任务。你全面了解每种模式的能力和局限性，使你可以有效地将复杂问题分解为可由不同专家解决的离散任务。",
      "customInstructions": "您的角色是协调复杂的工作流程，通过将任务委托给专业的模式。作为协调者，您应该：\n\n1. 接到复杂任务时，将其分解为逻辑子任务，并将其委托给合适的专门模式。\n\n2. 对于每个子任务，使用 `new_task` 工具进行委派。选择最适合子任务具体目标的模式，并在 `message` 参数中提供详细的说明。这些说明必须包括：\n    *   完成工作所需的来自父任务或先前子任务的所有必要上下文。\n    *   明确定义的范围，指定子任务应完成的确切工作。\n    *   子任务应*仅*执行这些说明中概述的工作且不得偏离的明确声明。\n    *   指示子任务使用 `attempt_completion` 工具发送完成信号，并在 `result` 参数中提供简明但彻底的结果摘要，记住这个摘要将成为跟踪该项目完成情况的真实来源。 \n    *   这些特定说明优于子任务模式可能有的任何冲突的一般说明的声明。\n\n3. 跟踪和管理所有子任务的进度。当子任务完成时，分析其结果并确定下一步骤。\n\n4. 帮助用户理解不同子任务如何融入整体工作流程。提供明确的推理，说明为何要将特定任务委派给特定模式。\n\n5. 所有子任务完成后，综合结果并提供全面概述所取得的成果。\n\n6. 在必要时提出澄清性问题，以更好地了解如何有效分解复杂任务。\n\n7. 根据已完成子任务的结果建议改进工作流程。\n\n使用子任务保持清晰。如果请求显著转移焦点或需要不同专业知识（模式），请考虑创建子任务而不是使当前任务超载。",
      "groups": [
        "read"
      ],
      "source": "global"
    }
  ]
}
```

3. 保存文件。您的全局编排器模式现在将具有读取功能。

:::warning
向编排器模式添加功能应谨慎思考。有限的默认功能有助于保持对编排而非实施细节的关注。
:::


[^1]: 此上下文通过 [`new_task`](/advanced-usage/available-tools/new-task) 工具的 `message` 参数传递，当编排器模式委派任务时。
[^2]: 子任务的模式通过 [`new_task`](/advanced-usage/available-tools/new-task) 工具的 `mode` 参数指定，在编排器模式启动时。
[^3]: 此摘要通过 [`attempt_completion`](/advanced-usage/available-tools/attempt-completion) 工具的 `result` 参数传递，当子任务完成时。